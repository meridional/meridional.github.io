<script src=lib1.js></script>

<body bgcolor=white>
<div align="center">
<canvas id='canvas1' width=400 height=400></canvas>
</div>
</body>

<script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader' type='x-shader/x-fragment'>
   precision mediump float;
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }


float noise(vec3 P) {
   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
   gx0 = fract(gx0); gx1 = fract(gx1);
   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                      dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                 vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                      dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
}

float fractal(vec3 P) {
  const int n = 3;
  float r = 0.;
  float p = 1.;
  for (int i = 0; i < n; i++) {
    r += noise(p * P) / p;
    p *= 2.0;
  }
  return r;
}

float turbulance(vec3 P) {
  const int n = 2;
  float r = 0.;
  float p = 1.;
  for (int i = 0; i < n; i++) {
    r += abs(noise(p * P)) / p;
    p *= 2.0;
  }
  return r;
}
   uniform float uTime;
   uniform vec3  uCursor;
   vec3 V, W;
   //uniform 
   varying vec3  vPosition;

   vec3 Lrgb;
   vec3 Ldir;

   // Compute intersection of a ray with a sphere, if any.  Return t.
   const float inf = 123456789.;
   float raySphere(vec3 V, vec3 W, vec4 S) {
      // YOU NEED TO COMPUTE t, BY SETTING UP AND THEN SOLVING A QUADRATIC EQUATION.
      vec3 vMinusS = V - S.xyz;
      float b = 2. * dot(vMinusS, W);
      float c = dot(vMinusS, vMinusS) - S.w * S.w;
      float d = b * b - 4. * c;
      if (d < 0.) return inf;
      d = sqrt(d);
      if (- d - b < -1e-9) {
        return inf;
      }
      return (-b - d) / 2.;
   }
   float fact = 0.8;
   vec2 raySphere2(vec3 V, vec3 W, vec4 S) {
      vec3 vMinusS = V - S.xyz;
      float b = 2. * dot(vMinusS, W);
      float c = dot(vMinusS, vMinusS) - S.w * S.w;
      float d = b * b - 4. * c;
      vec2 r;
      if (d < 0.) {
        r.x = inf;
        r.y = -inf;
      } else { 
        d = sqrt(d);
        r.x = (-b - d) / 2.;
        r.y = (-b + d) / 2.;
      }
     if (r.x < 0.) {
      r.x = inf;
      r.y = -inf;
     }
     return r;
   }


   void updateScene() {
      //Ldir = normalize(vec3(2.*cos(uTime/4.),+0.3-2.*abs(sin(uTime/4.)),-0.5));
      Ldir = vec3(0.,0.,-1.);
      Lrgb = vec3(.3,0.3,0.);
   }

   vec3 normal;
   float t;
   vec3 mat;
   vec4 spec;
   vec3 reflectW() {
      return 2.*normal * dot(normal, -W) + W;
      //fact *= .8;
   }
   vec3 shade() {
      vec3 color = mat / 5. ;
      float tt = inf;
      for (int j = 0; j < 1; j++) {
        vec3 r = reflectW();
        color = min(color +  Lrgb * (mat * max(0., dot(normal, -Ldir))
            + spec.rgb * pow(max(0.,dot(-Ldir, r)), spec.w/3.) // phong
            + spec.rgb * pow(max(0.,dot(normal, normalize(-W - Ldir))),spec.w)// blinn
        ),1.0);
      }
      return color ;
   }
   vec4 walls[12]; 
   vec4 wallSpecs[12];
   bool wallReflects[12];
   vec3 wallMats[12];
   vec3 wNormals[12];

   bool reflect = false;

   float rayTracePlane(vec3 v, vec3 w, vec4 wall) {
     float c = dot(wall.xyz,v);
     if (c + wall.w > 0.) return inf;
     float a = dot(wall.xyz, w);
     float b = -wall.w - c;
     if (abs(a) < 1e-9) return inf;
     float s = b / a;
     return s;
   }

   vec3 cubeAnchor;
   float cubeSideLength;
   vec3 cDir1;
   vec3 cDir2;
   vec3 cDir3;
   float dir2Turns[6]; // {1.0, -1.0, 1.0, -1.0, 1.0, -1.0};
   float dir3Turns[6]; // {1.0, -1.0, 1.0, -1.0, 1.0, -1.0};
    
   
   void makeCube() {
      cubeAnchor = vec3(-2.,-2.,-5.);
      float alpha = uTime;
      float beta = .0;
      vec3 cubeDir1 = vec3(1.,0.,0.);//normalize(vec3(sin(alpha),-cos(alpha)*sin(beta),-cos(alpha)*cos(beta)));
      vec3 cubeDir2 = vec3(0.,1.,0.);//normalize(vec3(cos(alpha),sin(alpha)*sin(beta),sin(alpha)*cos(beta)));
      cDir1 = cubeDir1;
      cDir2 = cubeDir2;
      cubeSideLength = 4.0;
      cDir3 = -cross(cubeDir1, cubeDir2);
      vec3 cubeDir3;
      vec3 atmp = cubeAnchor;
      /*float turns[6];
      turns[0] = 1.0;
      turns[1] = -1.0;
      turns[2] = 1.0;
      turns[3] = -1.;
      turns[4] = 1.;
      turns[5] = 1.;*/
      float dir = 1.0;
      for (int i = 0; i < 6; i++) {
        cubeDir3 = cross(cubeDir1, cubeDir2);   
        walls[i].xyz = -cubeDir3;
        walls[i].w = -dot(walls[i].xyz, atmp);
        wNormals[i] = -walls[i].xyz;
        wallMats[i] = vec3(.8,.8,.8);
        wallSpecs[i] = vec4(1.,1.,1.,10.);
        atmp = atmp + cubeDir1 * cubeSideLength;
        cubeDir1 = dir * cubeDir2;
        cubeDir2 = dir * cubeDir3;
        dir *= -1.0;
      }
   }

   vec3 tcMat;
   vec4 tcSpec;
   vec3 tcNormal;
   float traceCube(vec3 v, vec3 w) {
      for (int i = 0; i < 6; i++) {
         float tt = rayTracePlane(v,w,walls[i]);
         if (tt == inf) continue;
         vec3 tmp = v + w * tt - wNormals[i] * 0.0001;
         int c = 0;
         for (int j = 0; j < 6; j++) {
            if (dot(tmp,walls[j].xyz)+walls[j].w > 0.) c++;
            else break;
         }
         if (c == 6) {
            tcMat = wallMats[i];
            tcSpec = wallSpecs[i];
            tcNormal = wNormals[i];
            return tt;
         }
      }
      return inf;
   }

   vec3 shadeCube() {
      vec3 color = mat / 5.;
      //float gsize = cubeSideLength / 8.;
      //vec3 s = V - cubeAnchor;
 //     int ind = int(mod(floor(dot(s,cDir1) / gsize) + floor(dot(s,cDir2) / gsize)
  //            + floor(dot(s,cDir3) / gsize),2.));
   //   if (ind == 0) color = mat; 
//      color = color * (1.+turbulance(V));

      
      float tt = inf;
      for (int j = 0; j < 1; j++) {
   //     vec3 r = reflectW();
        color = min(color +  Lrgb * (mat * max(0., dot(normal, -Ldir))
   //         + spec.rgb * pow(max(0.,dot(-Ldir, r)), spec.w/3.) // phong
    //        + spec.rgb * pow(max(0.,dot(normal, normalize(-W - Ldir))),spec.w)// blinn
        ),1.0);
      }
      return color ;
   }

   void main(void) {
      //V = vec3(-uCursor.x *2. , -uCursor.y *2., 1.);
      V = vec3(0.,0.,1.);
      W = normalize(vec3(vPosition.x, vPosition.y, 0.)-V);
      updateScene();
      //makeWalls();
      makeCube();
      vec3 color;
      color = vec3(.0,.0,.0);
      normal = vec3(1.,0.,0.);
      float t = inf;
      t = traceCube(V,W);
      if (t != inf ) {
          V = V + t * W;
          normal = tcNormal;
          V = V + normal * 0.001;
          mat = tcMat;
          spec = tcSpec;
          color = shadeCube();
          gl_FragColor = vec4(sqrt(color),1.);
          return;
      }
     //discard;
//      color = vec3(0.3,.8,.4) * (0.5 + .5 * turbulance(W+(uTime)));
      float grid = .25;
      int inds = int(mod(floor(vPosition.x / grid) + (floor(vPosition.y / grid)), 2.0));
      if (inds == 0) color = vec3(.1,.1,.1);
      else color = vec3(.6,.6,.6);
    //  color = color * (0.2 + .8 * turbulance(2.*vec3(vPosition.x, vPosition.y ,0.)));
      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>

<script>
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>

