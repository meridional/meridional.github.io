<html>
<head>
<title>
Assignment 1: dancing mandelbrot set
</title>
<script src=lib1.js></script>


<script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
//   uniform float uTime;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<!!--==========================================================================

   Below is the fragment shader from class (with some slight improvements).

   Your assignment is to write your own interesting fragment shader program.
   Try to have fun with it  use "uTime" to create animated patterns, and
   "uCursor" to make it responsive to a user's mouse gestures.

   Try to make something as completely different from my "easter egg" example
   as possible :-)

============================================================================-->

<script id='my_fragment_shader' type='x-shader/x-fragment'>
   precision mediump float;
   uniform float uTime;
   uniform float uScale;
   uniform vec3  uCursor;
   varying vec3  vPosition;
   const int lim = 100;
   vec3 hsv2rgb(vec3 c)
   {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
   }
   void main() {
      //float c_re = (vPosition.x - uCursor.x- .6 - pow(uTime,2.28)) / pow(uTime,velo)*1.2  ;// * .3/ (uCursor.x);
      //float c_im = (vPosition.y-uCursor.y)*1.2/(pow(uTime,velo));//* .3/ (uCursor.y);
      float c_re = vPosition.x *uScale+ uCursor.x-.5;// * .3/ (uCursor.x);
      float c_im = vPosition.y *uScale+ uCursor.y;//* .3/ (uCursor.y);
      int iter = 0;
     // int lim_t = int(sin(uTime*0.3) * 20.0) ;
      //float x = uCursor.x, y = uCursor.y;
      float x = 0.+sin(1.1*uTime) * 0.1*sqrt(uScale), y = 0. + cos(1.3*uTime)*0.1*sqrt(uScale);
      float rr = x*x+y*y;
      float color = exp(-.01*sqrt(rr));
      for (int i = 0; i < lim; i++) {
        rr = x*x+y*y;
        color *= exp(-.01*sqrt(rr));
        if (rr > 5.) break;
        if (iter >= lim) break;
        float x_new = (x * x - y * y) + c_re ;
        y = 2.* x*y + c_im ;
        x = x_new;
        iter ++;
      }
      //if (iter == lim_t) gl_FragColor = vec4(x,abs(cos(y)+sin(x)),1.,1.);
      //else gl_FragColor = vec4(0.3,0.3,0.3,1.0);
      //float it_c = (1.-rr/5.) * (0.7+0.3*abs(rr*sin(.001/rr)));
      gl_FragColor = vec4(hsv2rgb(vec3(0.9+5.*((color)),0.7,1.0)), 1.0);
   }
   /*
   void main() {
      vec3 color = vec3(0., 0., 0.);                    // Set background color black.
      float x = vPosition.x;                            // Use only x and y coords of
      float y = vPosition.y;                            //   the square's geometry.
      float rr = (x * x + 5. * y * y) ;         // Compute radius squared.
      if (rr < 1.) {                                    // If pixel is on sphere:
         float z = sqrt(1. - rr);                       //    compute z.
         float t = .2 + .5 * max(0., x + y + z);        //    do shading.
         float zSlice = 1. - 3.3 * x + .5 * sin(uTime); //    check for slice.
         if (zSlice < z) {                              //    If pixel is on slice:
            z = zSlice;                                 //       adjust z,
	    t = z * z < 1. - rr ? .6 : 0.;              //       check for off shape,
         }                                              //       do flat shading.
         color = vec3(t, t, t);                         //    Make cool easter egg-like
         color.r *= 1. + .2 * cos(30. * tan(x + .5 * z + .03 * cos(20. * y))); // pattern.
      }
      gl_FragColor = vec4(color, 1.);
   }
   */
</script>

<script>
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>
</head>
<body>
  <h1>Dancing mandelbrot set</h1>
  <p>Click around to zoom in!</p>
<canvas id='canvas1' width='640' height='640'></canvas>
</body>
</html>
